var NonLocalStorage=function(){"use strict";function e(e,t,i,n){return new(i||(i=Promise))((function(s,r){function o(e){try{l(n.next(e))}catch(e){r(e)}}function a(e){try{l(n.throw(e))}catch(e){r(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(o,a)}l((n=n.apply(e,t||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;const t="NON_LOCAL_STORAGE_LOCAL_ID";function i(t,i){return e(this,arguments,void 0,(function*(e,t,i={algorithm:"AES-GCM"}){const n=new TextEncoder,s=crypto.getRandomValues(new Uint8Array(12)),r=yield crypto.subtle.encrypt({name:(null==i?void 0:i.algorithm)||"AES-GCM",iv:s},e,n.encode(t));return JSON.stringify({iv:btoa(String.fromCharCode(...s)),data:btoa(String.fromCharCode(...new Uint8Array(r)))})}))}function n(t,i){return e(this,arguments,void 0,(function*(e,t,i={algorithm:"AES-GCM"}){const n=JSON.parse(t),s=new TextDecoder,r=Uint8Array.from(atob(n.iv),(e=>e.charCodeAt(0))),o=Uint8Array.from(atob(n.data),(e=>e.charCodeAt(0))),a=yield crypto.subtle.decrypt({name:(null==i?void 0:i.algorithm)||"AES-GCM",iv:r},e,o);return s.decode(a)}))}let s;s="undefined"!=typeof crypto&&"function"==typeof crypto.randomUUID?()=>crypto.randomUUID():()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(e=>{const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)}));var r=s;const o=["error","warn","info","debug"];class a{constructor(e){this.level=e}log(e,t){o.indexOf(this.level)<o.indexOf(e)||console[e](t)}}function l(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4!=0;)t+="=";return atob(t)}function d(){const e="undefined"!=typeof window&&window.localStorage?window.localStorage.getItem(t):null;return e||`${r()}-${r()}`}const c="_undefined_";class h{constructor(e,i={id:d(),class:c,autoUpdateOldEncryptedValues:!0,logLevel:"warn"}){this.class=c;let n={class:c,logLevel:"warn"};if("string"==typeof i?(this.id=i,n={class:c,logLevel:"warn"}):(this.id=i.id||d(),n=i),this.logger=((e="warn")=>new a(e))(n.logLevel),!e||"object"!=typeof e||"string"!=typeof e.apiKey||"string"!=typeof e.apiSecret||"string"!=typeof e.projectId)throw new Error("Invalid credentials!");var s;s=this.id,"undefined"!=typeof window&&window.localStorage&&window.localStorage.setItem(t,s),this.credentials=e,this.class=n.class||c,n.passphrase&&(this.passphrase=n.passphrase),void 0===n.autoUpdateOldEncryptedValues&&(n.autoUpdateOldEncryptedValues=!0),this.autoUpdateOldEncryptedValues=n.autoUpdateOldEncryptedValues,n.idSignature&&(this.idSignature=n.idSignature),this.idSignature&&(this.idSignatureKeyVersion=n.idSignatureKeyVersion||0),this.isGettingAccessToken=this.getAccessToken(),this.isGettingAccessToken.finally((()=>{this.isGettingAccessToken=void 0}))}getAccessToken(){return e(this,void 0,void 0,(function*(){const e=yield this.request("GET","/auth/token"),t=function(e){if("string"!=typeof e)throw new Error("JWT must be a string");const t=e.split(".");if(3!==t.length)throw new Error("JWT should consist of three parts: header.payload.signature");const[i,n,s]=t,r=l(i);let o;try{o=JSON.parse(r)}catch(e){throw new Error("Invalid JWT header JSON: "+e.message)}const a=l(n);let d;try{d=JSON.parse(a)}catch(e){throw new Error("Invalid JWT payload JSON: "+e.message)}return{header:o,payload:d,signatureHex:function(e){let t="";for(let i=0;i<e.length;i++)t+=e.charCodeAt(i).toString(16).padStart(2,"0");return t}(l(s))}}(e);this.accessToken=e;const i=t.payload.exp-Date.now();setTimeout((()=>this.getAccessToken()),i-12e4)}))}getSymKey(t){return e(this,void 0,void 0,(function*(){return function(t,i,n){return e(this,arguments,void 0,(function*(e,t,i,n=1e5,s={hash:"SHA-512",derivedKeyType:{name:"AES-GCM",length:256}}){const r=new TextEncoder,o=yield crypto.subtle.importKey("raw",r.encode(e+":"+t),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:i,iterations:n,hash:(null==s?void 0:s.hash)||"SHA-512"},o,(null==s?void 0:s.derivedKeyType)||{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}))}(this.passphrase,this.id,t.salt)}))}getSymKeyForKeyVersion(t){return e(this,void 0,void 0,(function*(){if(t>-1&&(t!==this.encryptionSettings.keyVersion&&(this.previousEncryptionSettings&&0!==this.previousEncryptionSettings.length||(yield this.getEncryptionSettings())),t!==this.encryptionSettings.keyVersion)){if(!this.previousEncryptionSettings||0===this.previousEncryptionSettings.length)throw new Error(`Wrong keyVersion! Found ${t} but you're using ${this.encryptionSettings.keyVersion}`);let e=this.previousEncryptionSettings.find((e=>e.keyVersion===t));if(e||(yield this.getEncryptionSettings()),e=(this.previousEncryptionSettings||[]).find((e=>e.keyVersion===t)),!e)throw new Error(`Wrong keyVersion! Found ${t} but you're using ${this.encryptionSettings.keyVersion}`);return this.getSymKey(e)}return this.symKey}))}handleEncryptionSettings(t){return e(this,void 0,void 0,(function*(){var e,i;this.encryptionSettings={salt:Uint8Array.from(atob(null===(e=null==t?void 0:t.encryptionSettings)||void 0===e?void 0:e.salt),(e=>e.charCodeAt(0))),keyVersion:null===(i=null==t?void 0:t.encryptionSettings)||void 0===i?void 0:i.keyVersion},this.previousEncryptionSettings=((null==t?void 0:t.previousEncryptionSettings)||[]).map((e=>({salt:Uint8Array.from(atob(null==e?void 0:e.salt),(e=>e.charCodeAt(0))),keyVersion:null==e?void 0:e.keyVersion}))),this.symKey=yield this.getSymKey(this.encryptionSettings)}))}getEncryptionSettings(){return e(this,arguments,void 0,(function*(e=16){if(!this.passphrase)throw new Error("No passphrase passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption/${this.class}/${this.id}`,{saltLength:e});return this.handleEncryptionSettings(t)}))}rotateEncryption(){return e(this,arguments,void 0,(function*(e=16){if(!this.passphrase)throw new Error("No passphrase passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption-rotate/${this.class}/${this.id}`,{saltLength:e});return this.handleEncryptionSettings(t)}))}request(t,i,n){return e(this,void 0,void 0,(function*(){var e;!this.accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken);const s={Authorization:this.accessToken?`Bearer ${this.accessToken}`:`Basic ${btoa(`${this.credentials.apiKey}:${this.credentials.apiSecret}`)}`},r="string"==typeof n,o=null===(e=null==this?void 0:this.encryptionSettings)||void 0===e?void 0:e.keyVersion;void 0!==o&&o>-1&&(s["X-Enc-KV"]=o.toString()),this.idSignature&&void 0!==this.idSignatureKeyVersion&&(s["X-Id-Sig"]=this.idSignature,s["X-Id-Sig-KV"]=this.idSignatureKeyVersion.toString()),n&&(s["Content-Type"]=r?"text/plain":"application/json");const a=yield fetch(`${h.basePath}/project/${this.credentials.projectId}${i}`,{method:t,headers:s,body:n?r?n:JSON.stringify(n):void 0}),l=a.headers.get("content-type");let d;if(l)try{0===l.indexOf("text/plain")?d=yield a.text():0===l.indexOf("application/json")&&(d=yield a.json())}catch(e){d=`${a.status} - ${a.statusText}`}if(!a.ok){if("string"==typeof d)throw new Error(d);if(d)throw d;if(404!==a.status)throw new Error(`${a.status} - ${a.statusText}`)}return d}))}}h.basePath="http://localhost:5173";class y extends h{constructor(e,t){super(e,t),this.errorHandlers=[]}send(t){return e(this,arguments,void 0,(function*(e,t={transport:"ws"}){var n,s,r;if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");const o=this.symKey?yield i(this.symKey,JSON.stringify(e)):e;if("http"===t.transport){try{yield this.request("POST",`/message/${this.class}/${this.id}`,o)}catch(e){if(!e||"ConflictError"!==(null===(n=null==e?void 0:e.cause)||void 0===n?void 0:n.name))throw e;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),yield this.request("POST",`/message/${this.class}/${this.id}`,o)}return}const a=this.getWebSocket(),l={event:"message",payload:o};(null===(s=null==this?void 0:this.encryptionSettings)||void 0===s?void 0:s.keyVersion)>-1&&(l.keyVersion=null===(r=null==this?void 0:this.encryptionSettings)||void 0===r?void 0:r.keyVersion),a.send(JSON.stringify(l))}))}on(e,t,i){const s=this.getWebSocket();if("error"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;this.errorHandlers.push(e),s.addEventListener("error",(t=>e(new Error(null==t?void 0:t.message))))}if("connect"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;s.addEventListener("open",(()=>e()))}if("disconnect"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;s.addEventListener("close",(()=>e()))}const r=(e,t,i=!1)=>{var s;const r=i?e.keyVersion:e.payload.keyVersion;if(void 0===r)return t(e.payload);if(r>-1){if(!this.passphrase)return this.errorHandlers.map((e=>e(new Error("Encrypted data, but no passhprase configured!"))));if(!this.symKey)return this.errorHandlers.map((e=>e(new Error("Encrypted data, but getEncryptionSettings() not called!"))));if(r!==(null===(s=null==this?void 0:this.encryptionSettings)||void 0===s?void 0:s.keyVersion))return this.errorHandlers.map((e=>e(new Error("Wrong keyVersion! Call getEncryptionSettings() again!"))));let o=e.payload.value;i&&(o=e.payload),n(this.symKey,o).then((n=>{i?e.payload=JSON.parse(n):e.payload.value=JSON.parse(n),t(e.payload)})).catch((e=>{this.errorHandlers.map((t=>t(e)))}))}};if("message"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;s.addEventListener("message",(t=>{const i=JSON.parse(t.data);"message"===i.event&&r(i,e,!0)}))}if("setItem"===e)if(void 0===i){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;s.addEventListener("message",(t=>{const i=JSON.parse(t.data);"setItem"===i.event&&r(i,e)}))}else{if("function"!=typeof i)throw new Error("No event handler defined!");const e=i,n=t;s.addEventListener("message",(t=>{const i=JSON.parse(t.data);"setItem"===i.event&&i.payload.prop===n&&r(i,e)}))}if("removeItem"===e)if(void 0===i){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;s.addEventListener("message",(t=>{const i=JSON.parse(t.data);"removeItem"===i.event&&e(i.payload)}))}else{if("function"!=typeof i)throw new Error("No event handler defined!");const e=i,n=t;s.addEventListener("message",(t=>{const i=JSON.parse(t.data);"removeItem"===i.event&&i.payload.prop===n&&e(i.payload)}))}}disconnect(){this.ws&&(this.ws.close(),delete this.ws)}getWebSocket(){if(this.ws)return this.ws;const e=y.basePath.replace("http","ws"),t={auth:this.accessToken?`Bearer ${this.accessToken}`:`Basic ${btoa(`${this.credentials.apiKey}:${this.credentials.apiSecret}`)}`};this.idSignature&&void 0!==this.idSignatureKeyVersion&&(t.idSignature=this.idSignature,t.idSignatureKeyVersion=this.idSignatureKeyVersion);const i=new URLSearchParams(t),n=this.ws=new WebSocket(`${e}/project/${this.credentials.projectId}/ws/${this.class}/${this.id}?${i}`);return n.addEventListener("close",(()=>{delete this.ws})),n}}return class extends y{constructor(e,t){"string"==typeof t?super(e,t):(super(e,t),(null==t?void 0:t.ttl)&&(this.ttl=null==t?void 0:t.ttl))}setItem(t,n,s){return e(this,void 0,void 0,(function*(){var e,r;if(!t)throw new Error("No name passed!");if(!n)throw new Error("No value passed!");if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");const o=(null==s?void 0:s.ttl)||this.ttl,a=this.symKey?yield i(this.symKey,JSON.stringify(n)):n;let l;try{l=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}`,{value:a,ttl:o})}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),l=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}`,{value:a,ttl:o})}const d=l;return{expiresAt:null==d?void 0:d.expiresAt,keyVersion:null!==(r=null==d?void 0:d.keyVersion)&&void 0!==r?r:void 0}}))}setItems(t){return e(this,void 0,void 0,(function*(){var e,n;if(!t||0===Object.keys(t).length)throw new Error("No items passed!");if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");for(const e of Object.keys(t)){const s=this.symKey?yield i(this.symKey,JSON.stringify(t[e].value)):t[e].value;t[e].value=s,(n=t[e]).ttl||(n.ttl=this.ttl)}let s;try{s=yield this.request("POST",`/cache/${this.class}/${this.id}`,t)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),s=yield this.request("POST",`/cache/${this.class}/${this.id}`,t)}const r=s;return Object.keys(r).reduce(((e,t)=>{var i,n,s,o;return e[t]={expiresAt:null!==(n=null===(i=r[t])||void 0===i?void 0:i.expiresAt)&&void 0!==n?n:0,keyVersion:null!==(o=null===(s=r[t])||void 0===s?void 0:s.keyVersion)&&void 0!==o?o:void 0},e}),{})}))}getItem(t){return e(this,void 0,void 0,(function*(){var e,i;if(!t)throw new Error("No name passed!");if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");let s;try{s=yield this.request("GET",`/cache/${this.class}/${this.id}/${t}`)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),s=yield this.request("GET",`/cache/${this.class}/${this.id}/${t}`)}const r=s,o=null==r?void 0:r.value;if(!o)return;const a=yield this.getSymKeyForKeyVersion(r.keyVersion),l=a?JSON.parse(yield n(a,o)):o;return(null==r?void 0:r.keyVersion)>-1&&r.keyVersion!==(null===(i=this.encryptionSettings)||void 0===i?void 0:i.keyVersion)&&(this.autoUpdateOldEncryptedValues?(this.logger.log("info",`Item "${t}" has an old encryption and will be automatically updated now by setting it again.`),yield this.setItem(t,l,{ttl:r.expiresAt-Date.now()})):this.logger.log("warn",`Item "${t}" has an old encryption and can be updated by setting it again.`)),{value:l,expiresAt:r.expiresAt,keyVersion:r.keyVersion}}))}getItems(t){return e(this,void 0,void 0,(function*(){var e,i;if(!t||0===t.length)throw new Error("No names passed!");if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");let s;try{s=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,t)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),s=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,t)}const r=s;if(0===Object.keys(r).length)return;const o={},a={};for(const e of Object.keys(r)){const t=r[e],s=null==t?void 0:t.value;if(!s)continue;const l=yield this.getSymKeyForKeyVersion(t.keyVersion),d=l?JSON.parse(yield n(l,s)):s;(null==t?void 0:t.keyVersion)>-1&&t.keyVersion!==(null===(i=this.encryptionSettings)||void 0===i?void 0:i.keyVersion)&&(o[e]=t),a[e]={value:d,expiresAt:t.expiresAt,keyVersion:t.keyVersion}}const l=Object.keys(o);if(l.length>0)if(this.autoUpdateOldEncryptedValues){this.logger.log("info",`These items "${l.join(",")}" have an old encryption and will be automatically updated now by setting them again.`);const e=l.reduce(((e,t)=>(e[t]={value:a[t].value,ttl:o[t].expiresAt-Date.now()},e)),{});yield this.setItems(e)}else this.logger.log("warn",`These items "${l.join(",")}" have an old encryption and can be updated by setting them again.`);return a}))}getAllItems(t){return e(this,void 0,void 0,(function*(){var e,i;if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");let s;try{s=yield this.request("GET",`/cache/${this.class}/${this.id}${(null==t?void 0:t.prefix)?`?prefix=${null==t?void 0:t.prefix}`:""}`)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),s=yield this.request("GET",`/cache/${this.class}/${this.id}${(null==t?void 0:t.prefix)?`?prefix=${null==t?void 0:t.prefix}`:""}`)}const r=s;if(0===Object.keys(r).length)return;const o={};for(const e of Object.keys(r)){const t=r[e],s=null==t?void 0:t.value;if(!s)continue;const a=yield this.getSymKeyForKeyVersion(t.keyVersion),l=a?JSON.parse(yield n(a,s)):s;o[e]={value:l,expiresAt:t.expiresAt,keyVersion:null!==(i=t.keyVersion)&&void 0!==i?i:void 0}}return o}))}getAllKeys(t){return e(this,void 0,void 0,(function*(){return yield this.request("GET",`/cache-keys/${this.class}/${this.id}${(null==t?void 0:t.prefix)?`?prefix=${null==t?void 0:t.prefix}`:""}`)}))}removeItem(t){return e(this,void 0,void 0,(function*(){if(!t)throw new Error("No name passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}/${t}`)}))}removeItems(t){return e(this,void 0,void 0,(function*(){if(!t||0===t.length)throw new Error("No names passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}`,t)}))}clear(){return e(this,void 0,void 0,(function*(){yield this.request("DELETE",`/cache/${this.class}/${this.id}`)}))}}}();
