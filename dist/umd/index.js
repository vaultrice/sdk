var Vaultrice=function(e){"use strict";function t(e,t,n,i){return new(n||(n=Promise))((function(r,o){function s(e){try{l(i.next(e))}catch(e){o(e)}}function a(e){try{l(i.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((i=i.apply(e,t||[])).next())}))}"function"==typeof SuppressedError&&SuppressedError;const n="NON_LOCAL_STORAGE_LOCAL_ID";function i(e,n){return t(this,arguments,void 0,(function*(e,t,n={algorithm:"AES-GCM"}){const i=new TextEncoder,r=crypto.getRandomValues(new Uint8Array(12)),o=yield crypto.subtle.encrypt({name:(null==n?void 0:n.algorithm)||"AES-GCM",iv:r},e,i.encode(t));return JSON.stringify({iv:btoa(String.fromCharCode(...r)),data:btoa(String.fromCharCode(...new Uint8Array(o)))})}))}let r;r="undefined"!=typeof crypto&&"function"==typeof crypto.randomUUID?()=>crypto.randomUUID():()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(e=>{const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)}));var o=r;const s=["error","warn","info","debug"];class a{constructor(e){this.level=e}log(e,t){s.indexOf(this.level)<s.indexOf(e)||console[e](t)}}function l(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4!=0;)t+="=";return atob(t)}const d=Symbol("vaultrice/credentials"),c=Symbol("vaultrice/encryptionSettings"),h=Symbol("vaultrice/previousEncryptionSettings"),y=Symbol("vaultrice/errorHandlers"),u=Symbol("vaultrice/ws");function p(){const e="undefined"!=typeof window&&window.localStorage?window.localStorage.getItem(n):null;return e||`${o()}-${o()}`}const v="_undefined_";class g{constructor(e,r={id:p(),class:v,autoUpdateOldEncryptedValues:!0,logLevel:"warn"}){this.class=v;let o={class:v,logLevel:"warn"};if("string"==typeof r?(this.id=r,o={class:v,logLevel:"warn"}):(this.id=r.id||p(),o=r),this.logger=((e="warn")=>new a(e))(o.logLevel),!e||"object"!=typeof e||"string"!=typeof e.apiKey||"string"!=typeof e.apiSecret||"string"!=typeof e.projectId)throw new Error("Invalid credentials!");var s;if(s=this.id,"undefined"!=typeof window&&window.localStorage&&window.localStorage.setItem(n,s),this[d]=e,this.class=o.class||v,o.passphrase&&o.getEncryptionHandler)throw new Error("Either define a passphrase or a getEncryptionHandler, but not both!");o.getEncryptionHandler&&(this.getEncryptionHandler=o.getEncryptionHandler),o.passphrase&&(this.getEncryptionHandler=e=>t(this,void 0,void 0,(function*(){var n,r,s,a;const l=yield function(e,n,i){return t(this,arguments,void 0,(function*(e,t,n,i={iterations:1e5,hash:"SHA-512",derivedKeyType:{name:"AES-GCM",length:256}}){const r=new TextEncoder,o=yield crypto.subtle.importKey("raw",r.encode(e+":"+t),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:n,iterations:(null==i?void 0:i.iterations)||1e5,hash:(null==i?void 0:i.hash)||"SHA-512"},o,(null==i?void 0:i.derivedKeyType)||{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}))}(o.passphrase,this.id,e.salt,o.keyDerivationOptions),d=(null===(r=null===(n=o.keyDerivationOptions)||void 0===n?void 0:n.derivedKeyType)||void 0===r?void 0:r.name)?{algorithm:null===(a=null===(s=o.keyDerivationOptions)||void 0===s?void 0:s.derivedKeyType)||void 0===a?void 0:a.name}:void 0;return{encrypt:e=>i(l,e,d),decrypt:e=>function(e,n){return t(this,arguments,void 0,(function*(e,t,n={algorithm:"AES-GCM"}){const i=JSON.parse(t),r=new TextDecoder,o=Uint8Array.from(atob(i.iv),(e=>e.charCodeAt(0))),s=Uint8Array.from(atob(i.data),(e=>e.charCodeAt(0))),a=yield crypto.subtle.decrypt({name:(null==n?void 0:n.algorithm)||"AES-GCM",iv:o},e,s);return r.decode(a)}))}(l,e,d)}}))),void 0===o.autoUpdateOldEncryptedValues&&(o.autoUpdateOldEncryptedValues=!0),this.autoUpdateOldEncryptedValues=o.autoUpdateOldEncryptedValues,o.idSignature&&(this.idSignature=o.idSignature),this.idSignature&&(this.idSignatureKeyVersion=o.idSignatureKeyVersion||0),this.isGettingAccessToken=this.getAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0}),(()=>{this.isGettingAccessToken=void 0}))}getAccessToken(){return t(this,void 0,void 0,(function*(){const e=yield this.request("GET","/auth/token"),t=function(e){if("string"!=typeof e)throw new Error("JWT must be a string");const t=e.split(".");if(3!==t.length)throw new Error("JWT should consist of three parts: header.payload.signature");const[n,i,r]=t,o=l(n);let s;try{s=JSON.parse(o)}catch(e){throw new Error("Invalid JWT header JSON: "+e.message)}const a=l(i);let d;try{d=JSON.parse(a)}catch(e){throw new Error("Invalid JWT payload JSON: "+e.message)}return{header:s,payload:d,signatureHex:function(e){let t="";for(let n=0;n<e.length;n++)t+=e.charCodeAt(n).toString(16).padStart(2,"0");return t}(l(r))}}(e);this.accessToken=e;const n=t.payload.exp-Date.now();setTimeout((()=>this.getAccessToken()),n-12e4)}))}getEncryptionHandlerForKeyVersion(e){return t(this,void 0,void 0,(function*(){var t,n,i,r;if(e>-1&&(e!==(null===(t=this[c])||void 0===t?void 0:t.keyVersion)&&(this[h]&&0!==this[h].length||(yield this.getEncryptionSettings())),e!==(null===(n=this[c])||void 0===n?void 0:n.keyVersion))){if(!this[h]||0===this[h].length)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${null===(i=this[c])||void 0===i?void 0:i.keyVersion}`);let t=this[h].find((t=>t.keyVersion===e));if(t||(yield this.getEncryptionSettings()),t=(this[h]||[]).find((t=>t.keyVersion===e)),!t)throw new Error(`Wrong keyVersion! Found ${e} but you're using ${null===(r=this[c])||void 0===r?void 0:r.keyVersion}`);if(!this.getEncryptionHandler)return;return this.getEncryptionHandler(t)}return this.encryptionHandler}))}handleEncryptionSettings(e){return t(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No getEncryptionHandler defined!");this[c]=e.encryptionSettings,this[h]=e.previousEncryptionSettings,this.encryptionHandler=yield this.getEncryptionHandler(e.encryptionSettings)}))}prepareEncryptionSettings(e){var t,n,i;return{encryptionSettings:{salt:Uint8Array.from(atob(null===(t=null==e?void 0:e.encryptionSettings)||void 0===t?void 0:t.salt),(e=>e.charCodeAt(0))),keyVersion:null===(n=null==e?void 0:e.encryptionSettings)||void 0===n?void 0:n.keyVersion,createdAt:null===(i=null==e?void 0:e.encryptionSettings)||void 0===i?void 0:i.createdAt},previousEncryptionSettings:((null==e?void 0:e.previousEncryptionSettings)||[]).map((e=>({salt:Uint8Array.from(atob(null==e?void 0:e.salt),(e=>e.charCodeAt(0))),keyVersion:null==e?void 0:e.keyVersion,createdAt:null==e?void 0:e.createdAt})))}}getEncryptionSettings(){return t(this,arguments,void 0,(function*(e=16){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption/${this.class}/${this.id}`,{saltLength:e}),n=this.prepareEncryptionSettings(t);return yield this.handleEncryptionSettings(n),n}))}rotateEncryption(){return t(this,arguments,void 0,(function*(e=16){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const t=yield this.request("POST",`/cache-encryption-rotate/${this.class}/${this.id}`,{saltLength:e}),n=this.prepareEncryptionSettings(t);return yield this.handleEncryptionSettings(n),n}))}request(e,n,i){return t(this,void 0,void 0,(function*(){var t;!this.accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken);const r={Authorization:this.accessToken?`Bearer ${this.accessToken}`:`Basic ${btoa(`${this[d].apiKey}:${this[d].apiSecret}`)}`},o="string"==typeof i,s=null===(t=this[c])||void 0===t?void 0:t.keyVersion;void 0!==s&&s>-1&&(r["X-Enc-KV"]=s.toString()),this.idSignature&&void 0!==this.idSignatureKeyVersion&&(r["X-Id-Sig"]=this.idSignature,r["X-Id-Sig-KV"]=this.idSignatureKeyVersion.toString()),i&&(r["Content-Type"]=o?"text/plain":"application/json");const a=yield fetch(`${g.basePath}/project/${this[d].projectId}${n}`,{method:e,headers:r,body:i?o?i:JSON.stringify(i):void 0}),l=a.headers.get("content-type");let h;if(l)try{0===l.indexOf("text/plain")?h=yield a.text():0===l.indexOf("application/json")&&(h=yield a.json())}catch(e){h=`${a.status} - ${a.statusText}`}if(!a.ok){if("string"==typeof h)throw new Error(h);if(h)throw h;if(404!==a.status)throw new Error(`${a.status} - ${a.statusText}`)}return h}))}}g.basePath="https://api.vaultrice.app";class f extends g{constructor(e,t){super(e,t),this.hasJoined=!1,this[y]=[]}send(e){return t(this,arguments,void 0,(function*(e,t={transport:"ws"}){var n,i,r;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const o=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e)):e;if("http"===t.transport){try{yield this.request("POST",`/message/${this.class}/${this.id}`,o)}catch(e){if(!e||"ConflictError"!==(null===(n=null==e?void 0:e.cause)||void 0===n?void 0:n.name))throw e;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),yield this.request("POST",`/message/${this.class}/${this.id}`,o)}return}const s=this.getWebSocket(),a={event:"message",payload:o};this[c]&&(null===(i=this[c])||void 0===i?void 0:i.keyVersion)>-1&&(a.keyVersion=null===(r=this[c])||void 0===r?void 0:r.keyVersion),s.send(JSON.stringify(a))}))}on(e,t,n){const i=this.getWebSocket();if("error"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;this[y].push(e),i.addEventListener("error",(t=>e(new Error(null==t?void 0:t.message))))}if("connect"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;i.addEventListener("open",(()=>e()))}if("disconnect"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;i.addEventListener("close",(()=>e()))}const r=(e,t,n=!1)=>{const i=n?e.keyVersion:e.payload.keyVersion;if(void 0===i)return t(e.payload);if(i>-1){if(!this.getEncryptionHandler)return this[y].forEach((e=>e(new Error("Encrypted data, but no passphrase or getEncryptionHandler configured!"))));if(!this.encryptionHandler)return this[y].forEach((e=>e(new Error("Encrypted data, but getEncryptionSettings() not called!"))));let r=e.payload.value;n&&(r=e.payload),this.getEncryptionHandlerForKeyVersion(i).then((e=>null==e?void 0:e.decrypt(r))).then((i=>{n?e.payload=JSON.parse(i):e.payload.value=JSON.parse(i),t(e.payload)})).catch((e=>{this[y].forEach((t=>t(e)))}))}};if("message"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;i.addEventListener("message",(t=>{const n=JSON.parse(t.data);"message"===n.event&&r(n,e,!0)}))}if("presence:join"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;i.addEventListener("message",(t=>{const n=JSON.parse(t.data);"presence:join"===n.event&&r(n,(t=>{e({connectionId:null==n?void 0:n.connectionId,joinedAt:null==n?void 0:n.joinedAt,data:t})}),!0)}))}if("presence:leave"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;i.addEventListener("message",(t=>{const n=JSON.parse(t.data);"presence:leave"===n.event&&r(n,(t=>{e({connectionId:null==n?void 0:n.connectionId,data:t})}),!0)}))}if("setItem"===e)if(void 0===n){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;i.addEventListener("message",(t=>{const n=JSON.parse(t.data);"setItem"===n.event&&r(n,e)}))}else{if("function"!=typeof n)throw new Error("No event handler defined!");const e=n,o=t;i.addEventListener("message",(t=>{const n=JSON.parse(t.data);"setItem"===n.event&&n.payload.prop===o&&r(n,e)}))}if("removeItem"===e)if(void 0===n){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;i.addEventListener("message",(t=>{const n=JSON.parse(t.data);"removeItem"===n.event&&e(n.payload)}))}else{if("function"!=typeof n)throw new Error("No event handler defined!");const e=n,r=t;i.addEventListener("message",(t=>{const n=JSON.parse(t.data);"removeItem"===n.event&&n.payload.prop===r&&e(n.payload)}))}}disconnect(){this[u]&&(this.hasJoined&&this.leave(),this[u].close(),delete this[u])}getWebSocket(){if(this[u])return this[u];const e=f.basePath.replace("http","ws"),t={auth:this.accessToken?`Bearer ${this.accessToken}`:`Basic ${btoa(`${this[d].apiKey}:${this[d].apiSecret}`)}`};this.idSignature&&void 0!==this.idSignatureKeyVersion&&(t.idSignature=this.idSignature,t.idSignatureKeyVersion=this.idSignatureKeyVersion);const n=new URLSearchParams(t),i=this[u]=new WebSocket(`${e}/project/${this[d].projectId}/ws/${this.class}/${this.id}?${n}`);return i.addEventListener("close",(()=>{delete this[u],this.hasJoined&&(this.hasJoined=!1)})),i}join(e){return t(this,void 0,void 0,(function*(){var t,n;if(this.hasJoined=!0,this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e)):e,r=this.getWebSocket(),o={event:"presence:join",payload:i};this[c]&&(null===(t=this[c])||void 0===t?void 0:t.keyVersion)>-1&&(o.keyVersion=null===(n=this[c])||void 0===n?void 0:n.keyVersion),r.send(JSON.stringify(o))}))}leave(){return t(this,void 0,void 0,(function*(){var e,t;if(!this.hasJoined)return;this.hasJoined=!1;const n=this.getWebSocket(),i={event:"presence:leave"};this[c]&&(null===(e=this[c])||void 0===e?void 0:e.keyVersion)>-1&&(i.keyVersion=null===(t=this[c])||void 0===t?void 0:t.keyVersion),n.send(JSON.stringify(i))}))}getJoinedConnections(){return t(this,void 0,void 0,(function*(){var e;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let n;try{n=yield this.request("GET",`/presence-list/${this.class}/${this.id}`)}catch(t){if(!t||"ConflictError"!==(null===(e=null==t?void 0:t.cause)||void 0===e?void 0:e.name))throw t;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),n=yield this.request("GET",`/presence-list/${this.class}/${this.id}`)}const i=n;return Promise.all((null==i?void 0:i.map((e=>t(this,void 0,void 0,(function*(){const t=yield this.getEncryptionHandlerForKeyVersion(e.keyVersion),n=t?JSON.parse(yield t.decrypt(e.data)):e.data;return{connectionId:e.connectionId,joinedAt:e.joinedAt,data:n}})))))||[])}))}}let E=class extends f{constructor(e,t){"string"==typeof t?super(e,t):(super(e,t),(null==t?void 0:t.ttl)&&(this.ttl=null==t?void 0:t.ttl))}setItem(e,n,i){return t(this,void 0,void 0,(function*(){var t,r;if(!e)throw new Error("No name passed!");if(!n&&0!==n&&""!==n&&!1!==n)throw new Error("No value passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const o=(null==i?void 0:i.ttl)||this.ttl,s=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(n)):n;let a;try{a=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:s,ttl:o})}catch(n){if(!n||"ConflictError"!==(null===(t=null==n?void 0:n.cause)||void 0===t?void 0:t.name))throw n;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),a=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}`,{value:s,ttl:o})}const l=a;return{expiresAt:null==l?void 0:l.expiresAt,keyVersion:null!==(r=null==l?void 0:l.keyVersion)&&void 0!==r?r:void 0}}))}setItems(e){return t(this,void 0,void 0,(function*(){var t,n;if(!e||0===Object.keys(e).length)throw new Error("No items passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");for(const t of Object.keys(e)){const i=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e[t].value)):e[t].value;e[t].value=i,(n=e[t]).ttl||(n.ttl=this.ttl)}let i;try{i=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}catch(n){if(!n||"ConflictError"!==(null===(t=null==n?void 0:n.cause)||void 0===t?void 0:t.name))throw n;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),i=yield this.request("POST",`/cache/${this.class}/${this.id}`,e)}const r=i;return Object.keys(r).reduce(((e,t)=>{var n,i,o,s;return e[t]={expiresAt:null!==(i=null===(n=r[t])||void 0===n?void 0:n.expiresAt)&&void 0!==i?i:0,keyVersion:null!==(s=null===(o=r[t])||void 0===o?void 0:o.keyVersion)&&void 0!==s?s:void 0},e}),{})}))}getItem(e){return t(this,void 0,void 0,(function*(){var t,n;if(!e)throw new Error("No name passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let i;try{i=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}catch(n){if(!n||"ConflictError"!==(null===(t=null==n?void 0:n.cause)||void 0===t?void 0:t.name))throw n;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),i=yield this.request("GET",`/cache/${this.class}/${this.id}/${e}`)}const r=i,o=null==r?void 0:r.value;if(!o)return;const s=yield this.getEncryptionHandlerForKeyVersion(r.keyVersion),a=s?JSON.parse(yield s.decrypt(o)):o;return(null==r?void 0:r.keyVersion)>-1&&r.keyVersion!==(null===(n=this[c])||void 0===n?void 0:n.keyVersion)&&(this.autoUpdateOldEncryptedValues?(this.logger.log("info",`Item "${e}" has an old encryption and will be automatically updated now by setting it again.`),yield this.setItem(e,a,{ttl:r.expiresAt-Date.now()})):this.logger.log("warn",`Item "${e}" has an old encryption and can be updated by setting it again.`)),{value:a,expiresAt:r.expiresAt,keyVersion:r.keyVersion}}))}getItems(e){return t(this,void 0,void 0,(function*(){var t,n;if(!e||0===e.length)throw new Error("No names passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let i;try{i=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}catch(n){if(!n||"ConflictError"!==(null===(t=null==n?void 0:n.cause)||void 0===t?void 0:t.name))throw n;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),i=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,e)}const r=i;if(0===Object.keys(r).length)return;const o={},s={};for(const e of Object.keys(r)){const t=r[e],i=null==t?void 0:t.value;if(!i)continue;const a=yield this.getEncryptionHandlerForKeyVersion(t.keyVersion),l=a?JSON.parse(yield a.decrypt(i)):i;(null==t?void 0:t.keyVersion)>-1&&t.keyVersion!==(null===(n=this[c])||void 0===n?void 0:n.keyVersion)&&(o[e]=t),s[e]={value:l,expiresAt:t.expiresAt,keyVersion:t.keyVersion}}const a=Object.keys(o);if(a.length>0)if(this.autoUpdateOldEncryptedValues){this.logger.log("info",`These items "${a.join(",")}" have an old encryption and will be automatically updated now by setting them again.`);const e=a.reduce(((e,t)=>(e[t]={value:s[t].value,ttl:o[t].expiresAt-Date.now()},e)),{});yield this.setItems(e)}else this.logger.log("warn",`These items "${a.join(",")}" have an old encryption and can be updated by setting them again.`);return s}))}getAllItems(e){return t(this,void 0,void 0,(function*(){var t,n;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let i;try{i=yield this.request("GET",`/cache/${this.class}/${this.id}${(null==e?void 0:e.prefix)?`?prefix=${null==e?void 0:e.prefix}`:""}`)}catch(n){if(!n||"ConflictError"!==(null===(t=null==n?void 0:n.cause)||void 0===t?void 0:t.name))throw n;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),i=yield this.request("GET",`/cache/${this.class}/${this.id}${(null==e?void 0:e.prefix)?`?prefix=${null==e?void 0:e.prefix}`:""}`)}const r=i;if(0===Object.keys(r).length)return;const o={};for(const e of Object.keys(r)){const t=r[e],i=null==t?void 0:t.value;if(!i)continue;const s=yield this.getEncryptionHandlerForKeyVersion(t.keyVersion),a=s?JSON.parse(yield s.decrypt(i)):i;o[e]={value:a,expiresAt:t.expiresAt,keyVersion:null!==(n=t.keyVersion)&&void 0!==n?n:void 0}}return o}))}getAllKeys(e){return t(this,void 0,void 0,(function*(){return yield this.request("GET",`/cache-keys/${this.class}/${this.id}${(null==e?void 0:e.prefix)?`?prefix=${null==e?void 0:e.prefix}`:""}`)}))}removeItem(e){return t(this,void 0,void 0,(function*(){if(!e)throw new Error("No name passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}/${e}`)}))}removeItems(e){return t(this,void 0,void 0,(function*(){if(!e||0===e.length)throw new Error("No names passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}`,e)}))}incrementItem(e){return t(this,arguments,void 0,(function*(e,t=1,n){var i;if(!e)throw new Error("No name passed!");if(null==t)throw new Error("No value passed!");if("number"!=typeof t)throw new Error("Value needs to be a number!");const r=(null==n?void 0:n.ttl)||this.ttl,o=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/increment`,{value:t,ttl:r});return{value:null==o?void 0:o.value,expiresAt:null==o?void 0:o.expiresAt,keyVersion:null!==(i=null==o?void 0:o.keyVersion)&&void 0!==i?i:void 0}}))}decrementItem(e){return t(this,arguments,void 0,(function*(e,t=1,n){var i;if(!e)throw new Error("No name passed!");if(null==t)throw new Error("No value passed!");if("number"!=typeof t)throw new Error("Value needs to be a number!");const r=(null==n?void 0:n.ttl)||this.ttl,o=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/decrement`,{value:t,ttl:r});return{value:null==o?void 0:o.value,expiresAt:null==o?void 0:o.expiresAt,keyVersion:null!==(i=null==o?void 0:o.keyVersion)&&void 0!==i?i:void 0}}))}clear(){return t(this,void 0,void 0,(function*(){yield this.request("DELETE",`/cache/${this.class}/${this.id}`)}))}};const w=E,S=function(e,n){return t(this,void 0,void 0,(function*(){const t=new E(e,n),i=t.ttl||36e5,r={};t.getEncryptionHandler&&(yield t.getEncryptionSettings()),t.on("setItem",(e=>{r[e.prop]=Object.assign({},e),delete r[e.prop].prop})),t.on("removeItem",(e=>{delete r[e.prop]}));const o=yield t.getAllItems();o&&Object.keys(o).forEach((e=>{r[e]=o[e]}));const s={set:(e,n,o)=>void 0===o?(t.removeItem(n),delete r[n],!0):("number"==typeof o&&isNaN(o)&&(o=0),t.setItem(n,o),r[n]={value:o,expiresAt:Date.now()+i},!0),get(e,n){if("id"===n)return t.id;const i=r[n];if(i){if(!(i.expiresAt<Date.now()))return i.value;delete r[n]}}},a={id:t.id};return new Proxy(a,s)}))};return e.NonLocalStorage=w,e.createSyncObject=S,e}({});
