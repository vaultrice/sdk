import{__awaiter as t}from"./_virtual/_tslib.js";import{setLocalId as i,getLocalId as e}from"./local.js";import{deriveSymmetricKey as n,decrypt as s,encrypt as r}from"./encryption.js";import o from"./uuidv4.js";import a from"./logger.js";import d from"./decodeJwt.js";function c(){const t=e();return t||`${o()}-${o()}`}const p="_undefined_";class l{constructor(e,o={id:c(),class:p,autoUpdateOldEncryptedValues:!0,logLevel:"warn"}){this.class=p;let d={class:p,logLevel:"warn"};if("string"==typeof o?(this.id=o,d={class:p,logLevel:"warn"}):(this.id=o.id||c(),d=o),this.logger=a(d.logLevel),!e||"object"!=typeof e||"string"!=typeof e.apiKey||"string"!=typeof e.apiSecret||"string"!=typeof e.projectId)throw new Error("Invalid credentials!");if(i(this.id),this.credentials=e,this.class=d.class||p,d.passphrase&&d.getEncryptionHandler)throw new Error("Either define a passphrase or a getEncryptionHandler, but not both!");d.getEncryptionHandler&&(this.getEncryptionHandler=d.getEncryptionHandler),d.passphrase&&(this.getEncryptionHandler=i=>t(this,void 0,void 0,(function*(){var t,e,o,a;const c=yield n(d.passphrase,this.id,i.salt,d.keyDerivationOptions),p=(null===(e=null===(t=d.keyDerivationOptions)||void 0===t?void 0:t.derivedKeyType)||void 0===e?void 0:e.name)?{algorithm:null===(a=null===(o=d.keyDerivationOptions)||void 0===o?void 0:o.derivedKeyType)||void 0===a?void 0:a.name}:void 0;return{encrypt:t=>r(c,t,p),decrypt:t=>s(c,t,p)}}))),void 0===d.autoUpdateOldEncryptedValues&&(d.autoUpdateOldEncryptedValues=!0),this.autoUpdateOldEncryptedValues=d.autoUpdateOldEncryptedValues,d.idSignature&&(this.idSignature=d.idSignature),this.idSignature&&(this.idSignatureKeyVersion=d.idSignatureKeyVersion||0),this.isGettingAccessToken=this.getAccessToken(),this.isGettingAccessToken.finally((()=>{this.isGettingAccessToken=void 0}))}getAccessToken(){return t(this,void 0,void 0,(function*(){const t=yield this.request("GET","/auth/token"),i=d(t);this.accessToken=t;const e=i.payload.exp-Date.now();setTimeout((()=>this.getAccessToken()),e-12e4)}))}getEncryptionHandlerForKeyVersion(i){return t(this,void 0,void 0,(function*(){if(i>-1&&(i!==this.encryptionSettings.keyVersion&&(this.previousEncryptionSettings&&0!==this.previousEncryptionSettings.length||(yield this.getEncryptionSettings())),i!==this.encryptionSettings.keyVersion)){if(!this.previousEncryptionSettings||0===this.previousEncryptionSettings.length)throw new Error(`Wrong keyVersion! Found ${i} but you're using ${this.encryptionSettings.keyVersion}`);let t=this.previousEncryptionSettings.find((t=>t.keyVersion===i));if(t||(yield this.getEncryptionSettings()),t=(this.previousEncryptionSettings||[]).find((t=>t.keyVersion===i)),!t)throw new Error(`Wrong keyVersion! Found ${i} but you're using ${this.encryptionSettings.keyVersion}`);if(!this.getEncryptionHandler)return;return this.getEncryptionHandler(t)}return this.encryptionHandler}))}handleEncryptionSettings(i){return t(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No getEncryptionHandler defined!");this.encryptionSettings=i.encryptionSettings,this.previousEncryptionSettings=i.previousEncryptionSettings,this.encryptionHandler=yield this.getEncryptionHandler(i.encryptionSettings)}))}prepareEncryptionSettings(t){var i,e,n;return{encryptionSettings:{salt:Uint8Array.from(atob(null===(i=null==t?void 0:t.encryptionSettings)||void 0===i?void 0:i.salt),(t=>t.charCodeAt(0))),keyVersion:null===(e=null==t?void 0:t.encryptionSettings)||void 0===e?void 0:e.keyVersion,createdAt:null===(n=null==t?void 0:t.encryptionSettings)||void 0===n?void 0:n.createdAt},previousEncryptionSettings:((null==t?void 0:t.previousEncryptionSettings)||[]).map((t=>({salt:Uint8Array.from(atob(null==t?void 0:t.salt),(t=>t.charCodeAt(0))),keyVersion:null==t?void 0:t.keyVersion,createdAt:null==t?void 0:t.createdAt})))}}getEncryptionSettings(){return t(this,arguments,void 0,(function*(t=16){if(!this.passphrase&&!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const i=yield this.request("POST",`/cache-encryption/${this.class}/${this.id}`,{saltLength:t}),e=this.prepareEncryptionSettings(i);return yield this.handleEncryptionSettings(e),e}))}rotateEncryption(){return t(this,arguments,void 0,(function*(t=16){if(!this.passphrase&&!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const i=yield this.request("POST",`/cache-encryption-rotate/${this.class}/${this.id}`,{saltLength:t}),e=this.prepareEncryptionSettings(i);return yield this.handleEncryptionSettings(e),e}))}request(i,e,n){return t(this,void 0,void 0,(function*(){var t;!this.accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken);const s={Authorization:this.accessToken?`Bearer ${this.accessToken}`:`Basic ${btoa(`${this.credentials.apiKey}:${this.credentials.apiSecret}`)}`},r="string"==typeof n,o=null===(t=null==this?void 0:this.encryptionSettings)||void 0===t?void 0:t.keyVersion;void 0!==o&&o>-1&&(s["X-Enc-KV"]=o.toString()),this.idSignature&&void 0!==this.idSignatureKeyVersion&&(s["X-Id-Sig"]=this.idSignature,s["X-Id-Sig-KV"]=this.idSignatureKeyVersion.toString()),n&&(s["Content-Type"]=r?"text/plain":"application/json");const a=yield fetch(`${l.basePath}/project/${this.credentials.projectId}${e}`,{method:i,headers:s,body:n?r?n:JSON.stringify(n):void 0}),d=a.headers.get("content-type");let c;if(d)try{0===d.indexOf("text/plain")?c=yield a.text():0===d.indexOf("application/json")&&(c=yield a.json())}catch(t){c=`${a.status} - ${a.statusText}`}if(!a.ok){if("string"==typeof c)throw new Error(c);if(c)throw c;if(404!==a.status)throw new Error(`${a.status} - ${a.statusText}`)}return c}))}}l.basePath="http://localhost:5173";export{l as default};
