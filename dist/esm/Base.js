import{__awaiter as t}from"./_virtual/_tslib.js";import{setLocalId as i,getLocalId as e}from"./local.js";import{deriveSymmetricKey as n,decrypt as o,encrypt as s}from"./encryption.js";import r from"./uuidv4.js";import d from"./logger.js";import a from"./decodeJwt.js";import{CREDENTIALS as l,ENCRYPTION_SETTINGS as c,PREVIOUS_ENCRYPTION_SETTINGS as h}from"./symbols.js";function p(){const t=e();return t||`${r()}-${r()}`}const y="_undefined_";class u{constructor(e,r={id:p(),class:y,autoUpdateOldEncryptedValues:!0,logLevel:"warn"}){this.class=y;let a={class:y,logLevel:"warn"};if("string"==typeof r?(this.id=r,a={class:y,logLevel:"warn"}):(this.id=r.id||p(),a=r),this.logger=d(a.logLevel),!e||"object"!=typeof e||"string"!=typeof e.apiKey||"string"!=typeof e.apiSecret||"string"!=typeof e.projectId)throw new Error("Invalid credentials!");if(i(this.id),this[l]=e,this.class=a.class||y,a.passphrase&&a.getEncryptionHandler)throw new Error("Either define a passphrase or a getEncryptionHandler, but not both!");a.getEncryptionHandler&&(this.getEncryptionHandler=a.getEncryptionHandler),a.passphrase&&(this.getEncryptionHandler=i=>t(this,void 0,void 0,(function*(){var t,e,r,d;const l=yield n(a.passphrase,this.id,i.salt,a.keyDerivationOptions),c=(null===(e=null===(t=a.keyDerivationOptions)||void 0===t?void 0:t.derivedKeyType)||void 0===e?void 0:e.name)?{algorithm:null===(d=null===(r=a.keyDerivationOptions)||void 0===r?void 0:r.derivedKeyType)||void 0===d?void 0:d.name}:void 0;return{encrypt:t=>s(l,t,c),decrypt:t=>o(l,t,c)}}))),void 0===a.autoUpdateOldEncryptedValues&&(a.autoUpdateOldEncryptedValues=!0),this.autoUpdateOldEncryptedValues=a.autoUpdateOldEncryptedValues,a.idSignature&&(this.idSignature=a.idSignature),this.idSignature&&(this.idSignatureKeyVersion=a.idSignatureKeyVersion||0),this.isGettingAccessToken=this.getAccessToken(),this.isGettingAccessToken.then((()=>{this.isGettingAccessToken=void 0}),(()=>{this.isGettingAccessToken=void 0}))}getAccessToken(){return t(this,void 0,void 0,(function*(){const t=yield this.request("GET","/auth/token"),i=a(t);this.accessToken=t;const e=i.payload.exp-Date.now();setTimeout((()=>this.getAccessToken()),e-12e4)}))}getEncryptionHandlerForKeyVersion(i){return t(this,void 0,void 0,(function*(){var t,e,n,o;if(i>-1&&(i!==(null===(t=this[c])||void 0===t?void 0:t.keyVersion)&&(this[h]&&0!==this[h].length||(yield this.getEncryptionSettings())),i!==(null===(e=this[c])||void 0===e?void 0:e.keyVersion))){if(!this[h]||0===this[h].length)throw new Error(`Wrong keyVersion! Found ${i} but you're using ${null===(n=this[c])||void 0===n?void 0:n.keyVersion}`);let t=this[h].find((t=>t.keyVersion===i));if(t||(yield this.getEncryptionSettings()),t=(this[h]||[]).find((t=>t.keyVersion===i)),!t)throw new Error(`Wrong keyVersion! Found ${i} but you're using ${null===(o=this[c])||void 0===o?void 0:o.keyVersion}`);if(!this.getEncryptionHandler)return;return this.getEncryptionHandler(t)}return this.encryptionHandler}))}handleEncryptionSettings(i){return t(this,void 0,void 0,(function*(){if(!this.getEncryptionHandler)throw new Error("No getEncryptionHandler defined!");this[c]=i.encryptionSettings,this[h]=i.previousEncryptionSettings,this.encryptionHandler=yield this.getEncryptionHandler(i.encryptionSettings)}))}prepareEncryptionSettings(t){var i,e,n;return{encryptionSettings:{salt:Uint8Array.from(atob(null===(i=null==t?void 0:t.encryptionSettings)||void 0===i?void 0:i.salt),(t=>t.charCodeAt(0))),keyVersion:null===(e=null==t?void 0:t.encryptionSettings)||void 0===e?void 0:e.keyVersion,createdAt:null===(n=null==t?void 0:t.encryptionSettings)||void 0===n?void 0:n.createdAt},previousEncryptionSettings:((null==t?void 0:t.previousEncryptionSettings)||[]).map((t=>({salt:Uint8Array.from(atob(null==t?void 0:t.salt),(t=>t.charCodeAt(0))),keyVersion:null==t?void 0:t.keyVersion,createdAt:null==t?void 0:t.createdAt})))}}getEncryptionSettings(){return t(this,arguments,void 0,(function*(t=16){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const i=yield this.request("POST",`/cache-encryption/${this.class}/${this.id}`,{saltLength:t}),e=this.prepareEncryptionSettings(i);return yield this.handleEncryptionSettings(e),e}))}rotateEncryption(){return t(this,arguments,void 0,(function*(t=16){if(!this.getEncryptionHandler)throw new Error("No passphrase and no getEncryptionHandler passed! This function is only allowed with e2e encryption!");const i=yield this.request("POST",`/cache-encryption-rotate/${this.class}/${this.id}`,{saltLength:t}),e=this.prepareEncryptionSettings(i);return yield this.handleEncryptionSettings(e),e}))}request(i,e,n){return t(this,void 0,void 0,(function*(){var t;!this.accessToken&&this.isGettingAccessToken&&(yield this.isGettingAccessToken);const o={Authorization:this.accessToken?`Bearer ${this.accessToken}`:`Basic ${btoa(`${this[l].apiKey}:${this[l].apiSecret}`)}`},s="string"==typeof n,r=null===(t=this[c])||void 0===t?void 0:t.keyVersion;void 0!==r&&r>-1&&(o["X-Enc-KV"]=r.toString()),this.idSignature&&void 0!==this.idSignatureKeyVersion&&(o["X-Id-Sig"]=this.idSignature,o["X-Id-Sig-KV"]=this.idSignatureKeyVersion.toString()),n&&(o["Content-Type"]=s?"text/plain":"application/json");const d=yield fetch(`${u.basePath}/project/${this[l].projectId}${e}`,{method:i,headers:o,body:n?s?n:JSON.stringify(n):void 0}),a=d.headers.get("content-type");let h;if(a)try{0===a.indexOf("text/plain")?h=yield d.text():0===a.indexOf("application/json")&&(h=yield d.json())}catch(t){h=`${d.status} - ${d.statusText}`}if(!d.ok){if("string"==typeof h)throw new Error(h);if(h)throw h;if(404!==d.status)throw new Error(`${d.status} - ${d.statusText}`)}return h}))}}u.basePath="https://api.vaultrice.app";export{u as default};
