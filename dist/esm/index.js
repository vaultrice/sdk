import{__awaiter as e}from"./_virtual/_tslib.js";import t from"./ws.js";import{encrypt as i,decrypt as s}from"./encryption.js";class o extends t{constructor(e,t){"string"==typeof t?super(e,t):(super(e,t),(null==t?void 0:t.ttl)&&(this.ttl=null==t?void 0:t.ttl))}setItem(t,s,o){return e(this,void 0,void 0,(function*(){var e,n;if(!t)throw new Error("No name passed!");if(!s)throw new Error("No value passed!");if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");const r=(null==o?void 0:o.ttl)||this.ttl,l=this.symKey?yield i(this.symKey,JSON.stringify(s)):s;let h;try{h=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}`,{value:l,ttl:r})}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),h=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}`,{value:l,ttl:r})}const a=h;return{expiresAt:null==a?void 0:a.expiresAt,keyVersion:null!==(n=null==a?void 0:a.keyVersion)&&void 0!==n?n:void 0}}))}setItems(t){return e(this,void 0,void 0,(function*(){var e,s;if(!t||0===Object.keys(t).length)throw new Error("No items passed!");if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");for(const e of Object.keys(t)){const o=this.symKey?yield i(this.symKey,JSON.stringify(t[e].value)):t[e].value;t[e].value=o,(s=t[e]).ttl||(s.ttl=this.ttl)}let o;try{o=yield this.request("POST",`/cache/${this.class}/${this.id}`,t)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("POST",`/cache/${this.class}/${this.id}`,t)}const n=o;return Object.keys(n).reduce(((e,t)=>{var i,s,o,r;return e[t]={expiresAt:null!==(s=null===(i=n[t])||void 0===i?void 0:i.expiresAt)&&void 0!==s?s:0,keyVersion:null!==(r=null===(o=n[t])||void 0===o?void 0:o.keyVersion)&&void 0!==r?r:void 0},e}),{})}))}getItem(t){return e(this,void 0,void 0,(function*(){var e,i;if(!t)throw new Error("No name passed!");if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");let o;try{o=yield this.request("GET",`/cache/${this.class}/${this.id}/${t}`)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("GET",`/cache/${this.class}/${this.id}/${t}`)}const n=o,r=null==n?void 0:n.value;if(!r)return;const l=yield this.getSymKeyForKeyVersion(n.keyVersion),h=l?JSON.parse(yield s(l,r)):r;return(null==n?void 0:n.keyVersion)>-1&&n.keyVersion!==(null===(i=this.encryptionSettings)||void 0===i?void 0:i.keyVersion)&&(this.autoUpdateOldEncryptedValues?(this.logger.log("info",`Item "${t}" has an old encryption and will be automatically updated now by setting it again.`),yield this.setItem(t,h,{ttl:n.expiresAt-Date.now()})):this.logger.log("warn",`Item "${t}" has an old encryption and can be updated by setting it again.`)),{value:h,expiresAt:n.expiresAt,keyVersion:n.keyVersion}}))}getItems(t){return e(this,void 0,void 0,(function*(){var e,i;if(!t||0===t.length)throw new Error("No names passed!");if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");let o;try{o=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,t)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,t)}const n=o;if(0===Object.keys(n).length)return;const r={},l={};for(const e of Object.keys(n)){const t=n[e],o=null==t?void 0:t.value;if(!o)continue;const h=yield this.getSymKeyForKeyVersion(t.keyVersion),a=h?JSON.parse(yield s(h,o)):o;(null==t?void 0:t.keyVersion)>-1&&t.keyVersion!==(null===(i=this.encryptionSettings)||void 0===i?void 0:i.keyVersion)&&(r[e]=t),l[e]={value:a,expiresAt:t.expiresAt,keyVersion:t.keyVersion}}const h=Object.keys(r);if(h.length>0)if(this.autoUpdateOldEncryptedValues){this.logger.log("info",`These items "${h.join(",")}" have an old encryption and will be automatically updated now by setting them again.`);const e=h.reduce(((e,t)=>(e[t]={value:l[t].value,ttl:r[t].expiresAt-Date.now()},e)),{});yield this.setItems(e)}else this.logger.log("warn",`These items "${h.join(",")}" have an old encryption and can be updated by setting them again.`);return l}))}getAllItems(t){return e(this,void 0,void 0,(function*(){var e,i;if(this.passphrase&&!this.symKey)throw new Error("Call getEncryptionSettings() first!");let o;try{o=yield this.request("GET",`/cache/${this.class}/${this.id}${(null==t?void 0:t.prefix)?`?prefix=${null==t?void 0:t.prefix}`:""}`)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),o=yield this.request("GET",`/cache/${this.class}/${this.id}${(null==t?void 0:t.prefix)?`?prefix=${null==t?void 0:t.prefix}`:""}`)}const n=o;if(0===Object.keys(n).length)return;const r={};for(const e of Object.keys(n)){const t=n[e],o=null==t?void 0:t.value;if(!o)continue;const l=yield this.getSymKeyForKeyVersion(t.keyVersion),h=l?JSON.parse(yield s(l,o)):o;r[e]={value:h,expiresAt:t.expiresAt,keyVersion:null!==(i=t.keyVersion)&&void 0!==i?i:void 0}}return r}))}getAllKeys(t){return e(this,void 0,void 0,(function*(){return yield this.request("GET",`/cache-keys/${this.class}/${this.id}${(null==t?void 0:t.prefix)?`?prefix=${null==t?void 0:t.prefix}`:""}`)}))}removeItem(t){return e(this,void 0,void 0,(function*(){if(!t)throw new Error("No name passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}/${t}`)}))}removeItems(t){return e(this,void 0,void 0,(function*(){if(!t||0===t.length)throw new Error("No names passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}`,t)}))}clear(){return e(this,void 0,void 0,(function*(){yield this.request("DELETE",`/cache/${this.class}/${this.id}`)}))}}export{o as default};
