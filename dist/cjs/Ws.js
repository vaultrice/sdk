"use strict";var e=require("./_virtual/_tslib.js"),t=require("./Base.js"),n=require("./symbols.js");class i extends t{constructor(e,t){super(e,t),this.hasJoined=!1,this[n.ERROR_HANDLERS]=[]}send(t){return e.__awaiter(this,arguments,void 0,(function*(e,t={transport:"ws"}){var i,o,r;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const s=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(e)):e;if("http"===t.transport){try{yield this.request("POST",`/message/${this.class}/${this.id}`,s)}catch(e){if(!e||"ConflictError"!==(null===(i=null==e?void 0:e.cause)||void 0===i?void 0:i.name))throw e;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),yield this.request("POST",`/message/${this.class}/${this.id}`,s)}return}const a=this.getWebSocket(),d={event:"message",payload:s};this[n.ENCRYPTION_SETTINGS]&&(null===(o=this[n.ENCRYPTION_SETTINGS])||void 0===o?void 0:o.keyVersion)>-1&&(d.keyVersion=null===(r=this[n.ENCRYPTION_SETTINGS])||void 0===r?void 0:r.keyVersion),a.send(JSON.stringify(d))}))}on(e,t,i){const o=this.getWebSocket();if("error"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;this[n.ERROR_HANDLERS].push(e),o.addEventListener("error",(t=>e(new Error(null==t?void 0:t.message))))}if("connect"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;o.addEventListener("open",(()=>e()))}if("disconnect"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;o.addEventListener("close",(()=>e()))}const r=(e,t,i=!1)=>{const o=i?e.keyVersion:e.payload.keyVersion;if(void 0===o)return t(e.payload);if(o>-1){if(!this.getEncryptionHandler)return this[n.ERROR_HANDLERS].forEach((e=>e(new Error("Encrypted data, but no passphrase or getEncryptionHandler configured!"))));if(!this.encryptionHandler)return this[n.ERROR_HANDLERS].forEach((e=>e(new Error("Encrypted data, but getEncryptionSettings() not called!"))));let r=e.payload.value;i&&(r=e.payload),this.getEncryptionHandlerForKeyVersion(o).then((e=>null==e?void 0:e.decrypt(r))).then((n=>{i?e.payload=JSON.parse(n):e.payload.value=JSON.parse(n),t(e.payload)})).catch((e=>{this[n.ERROR_HANDLERS].forEach((t=>t(e)))}))}};if("message"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;o.addEventListener("message",(t=>{const n=JSON.parse(t.data);"message"===n.event&&r(n,e,!0)}))}if("presence:join"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;o.addEventListener("message",(t=>{const n=JSON.parse(t.data);"presence:join"===n.event&&r(n,(t=>{e({connectionId:null==n?void 0:n.connectionId,joinedAt:null==n?void 0:n.joinedAt,data:t})}),!0)}))}if("presence:leave"===e){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;o.addEventListener("message",(t=>{const n=JSON.parse(t.data);"presence:leave"===n.event&&r(n,(t=>{e({connectionId:null==n?void 0:n.connectionId,data:t})}),!0)}))}if("setItem"===e)if(void 0===i){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;o.addEventListener("message",(t=>{const n=JSON.parse(t.data);"setItem"===n.event&&r(n,e)}))}else{if("function"!=typeof i)throw new Error("No event handler defined!");const e=i,n=t;o.addEventListener("message",(t=>{const i=JSON.parse(t.data);"setItem"===i.event&&i.payload.prop===n&&r(i,e)}))}if("removeItem"===e)if(void 0===i){if("function"!=typeof t)throw new Error("No event handler defined!");const e=t;o.addEventListener("message",(t=>{const n=JSON.parse(t.data);"removeItem"===n.event&&e(n.payload)}))}else{if("function"!=typeof i)throw new Error("No event handler defined!");const e=i,n=t;o.addEventListener("message",(t=>{const i=JSON.parse(t.data);"removeItem"===i.event&&i.payload.prop===n&&e(i.payload)}))}}disconnect(){this[n.WEBSOCKET]&&(this.hasJoined&&this.leave(),this[n.WEBSOCKET].close(),delete this[n.WEBSOCKET])}getWebSocket(){if(this[n.WEBSOCKET])return this[n.WEBSOCKET];const e=i.basePath.replace("http","ws"),t={auth:this.accessToken?`Bearer ${this.accessToken}`:`Basic ${btoa(`${this[n.CREDENTIALS].apiKey}:${this[n.CREDENTIALS].apiSecret}`)}`};this.idSignature&&void 0!==this.idSignatureKeyVersion&&(t.idSignature=this.idSignature,t.idSignatureKeyVersion=this.idSignatureKeyVersion);const o=new URLSearchParams(t),r=this[n.WEBSOCKET]=new WebSocket(`${e}/project/${this[n.CREDENTIALS].projectId}/ws/${this.class}/${this.id}?${o}`);return r.addEventListener("close",(()=>{delete this[n.WEBSOCKET],this.hasJoined&&(this.hasJoined=!1)})),r}join(t){return e.__awaiter(this,void 0,void 0,(function*(){var e,i;if(this.hasJoined=!0,this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const o=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(t)):t,r=this.getWebSocket(),s={event:"presence:join",payload:o};this[n.ENCRYPTION_SETTINGS]&&(null===(e=this[n.ENCRYPTION_SETTINGS])||void 0===e?void 0:e.keyVersion)>-1&&(s.keyVersion=null===(i=this[n.ENCRYPTION_SETTINGS])||void 0===i?void 0:i.keyVersion),r.send(JSON.stringify(s))}))}leave(){return e.__awaiter(this,void 0,void 0,(function*(){var e,t;if(!this.hasJoined)return;this.hasJoined=!1;const i=this.getWebSocket(),o={event:"presence:leave"};this[n.ENCRYPTION_SETTINGS]&&(null===(e=this[n.ENCRYPTION_SETTINGS])||void 0===e?void 0:e.keyVersion)>-1&&(o.keyVersion=null===(t=this[n.ENCRYPTION_SETTINGS])||void 0===t?void 0:t.keyVersion),i.send(JSON.stringify(o))}))}getJoinedConnections(){return e.__awaiter(this,void 0,void 0,(function*(){var t;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let n;try{n=yield this.request("GET",`/presence-list/${this.class}/${this.id}`)}catch(e){if(!e||"ConflictError"!==(null===(t=null==e?void 0:e.cause)||void 0===t?void 0:t.name))throw e;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),n=yield this.request("GET",`/presence-list/${this.class}/${this.id}`)}const i=n;return Promise.all((null==i?void 0:i.map((t=>e.__awaiter(this,void 0,void 0,(function*(){const e=yield this.getEncryptionHandlerForKeyVersion(t.keyVersion),n=e?JSON.parse(yield e.decrypt(t.data)):t.data;return{connectionId:t.connectionId,joinedAt:t.joinedAt,data:n}})))))||[])}))}}module.exports=i;
