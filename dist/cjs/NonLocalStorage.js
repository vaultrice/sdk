"use strict";var e=require("./_virtual/_tslib.js"),t=require("./Ws.js");module.exports=class extends t{constructor(e,t){"string"==typeof t?super(e,t):(super(e,t),(null==t?void 0:t.ttl)&&(this.ttl=null==t?void 0:t.ttl))}setItem(t,i,n){return e.__awaiter(this,void 0,void 0,(function*(){var e,r;if(!t)throw new Error("No name passed!");if(!i&&0!==i&&""!==i&&!1!==i)throw new Error("No value passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");const s=(null==n?void 0:n.ttl)||this.ttl,o=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(i)):i;let l;try{l=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}`,{value:o,ttl:s})}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),l=yield this.request("POST",`/cache/${this.class}/${this.id}/${t}`,{value:o,ttl:s})}const a=l;return{expiresAt:null==a?void 0:a.expiresAt,keyVersion:null!==(r=null==a?void 0:a.keyVersion)&&void 0!==r?r:void 0}}))}setItems(t){return e.__awaiter(this,void 0,void 0,(function*(){var e,i;if(!t||0===Object.keys(t).length)throw new Error("No items passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");for(const e of Object.keys(t)){const n=this.encryptionHandler?yield this.encryptionHandler.encrypt(JSON.stringify(t[e].value)):t[e].value;t[e].value=n,(i=t[e]).ttl||(i.ttl=this.ttl)}let n;try{n=yield this.request("POST",`/cache/${this.class}/${this.id}`,t)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),n=yield this.request("POST",`/cache/${this.class}/${this.id}`,t)}const r=n;return Object.keys(r).reduce(((e,t)=>{var i,n,s,o;return e[t]={expiresAt:null!==(n=null===(i=r[t])||void 0===i?void 0:i.expiresAt)&&void 0!==n?n:0,keyVersion:null!==(o=null===(s=r[t])||void 0===s?void 0:s.keyVersion)&&void 0!==o?o:void 0},e}),{})}))}getItem(t){return e.__awaiter(this,void 0,void 0,(function*(){var e,i;if(!t)throw new Error("No name passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let n;try{n=yield this.request("GET",`/cache/${this.class}/${this.id}/${t}`)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),n=yield this.request("GET",`/cache/${this.class}/${this.id}/${t}`)}const r=n,s=null==r?void 0:r.value;if(!s)return;const o=yield this.getEncryptionHandlerForKeyVersion(r.keyVersion),l=o?JSON.parse(yield o.decrypt(s)):s;return(null==r?void 0:r.keyVersion)>-1&&r.keyVersion!==(null===(i=this.encryptionSettings)||void 0===i?void 0:i.keyVersion)&&(this.autoUpdateOldEncryptedValues?(this.logger.log("info",`Item "${t}" has an old encryption and will be automatically updated now by setting it again.`),yield this.setItem(t,l,{ttl:r.expiresAt-Date.now()})):this.logger.log("warn",`Item "${t}" has an old encryption and can be updated by setting it again.`)),{value:l,expiresAt:r.expiresAt,keyVersion:r.keyVersion}}))}getItems(t){return e.__awaiter(this,void 0,void 0,(function*(){var e,i;if(!t||0===t.length)throw new Error("No names passed!");if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let n;try{n=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,t)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),n=yield this.request("POST",`/cache-query/${this.class}/${this.id}`,t)}const r=n;if(0===Object.keys(r).length)return;const s={},o={};for(const e of Object.keys(r)){const t=r[e],n=null==t?void 0:t.value;if(!n)continue;const l=yield this.getEncryptionHandlerForKeyVersion(t.keyVersion),a=l?JSON.parse(yield l.decrypt(n)):n;(null==t?void 0:t.keyVersion)>-1&&t.keyVersion!==(null===(i=this.encryptionSettings)||void 0===i?void 0:i.keyVersion)&&(s[e]=t),o[e]={value:a,expiresAt:t.expiresAt,keyVersion:t.keyVersion}}const l=Object.keys(s);if(l.length>0)if(this.autoUpdateOldEncryptedValues){this.logger.log("info",`These items "${l.join(",")}" have an old encryption and will be automatically updated now by setting them again.`);const e=l.reduce(((e,t)=>(e[t]={value:o[t].value,ttl:s[t].expiresAt-Date.now()},e)),{});yield this.setItems(e)}else this.logger.log("warn",`These items "${l.join(",")}" have an old encryption and can be updated by setting them again.`);return o}))}getAllItems(t){return e.__awaiter(this,void 0,void 0,(function*(){var e,i;if(this.getEncryptionHandler&&!this.encryptionHandler)throw new Error("Call getEncryptionSettings() first!");let n;try{n=yield this.request("GET",`/cache/${this.class}/${this.id}${(null==t?void 0:t.prefix)?`?prefix=${null==t?void 0:t.prefix}`:""}`)}catch(i){if(!i||"ConflictError"!==(null===(e=null==i?void 0:i.cause)||void 0===e?void 0:e.name))throw i;this.logger.log("warn","Your local keyVersion does not match! Will attempt to fetch the new encryption settings..."),yield this.getEncryptionSettings(),n=yield this.request("GET",`/cache/${this.class}/${this.id}${(null==t?void 0:t.prefix)?`?prefix=${null==t?void 0:t.prefix}`:""}`)}const r=n;if(0===Object.keys(r).length)return;const s={};for(const e of Object.keys(r)){const t=r[e],n=null==t?void 0:t.value;if(!n)continue;const o=yield this.getEncryptionHandlerForKeyVersion(t.keyVersion),l=o?JSON.parse(yield o.decrypt(n)):n;s[e]={value:l,expiresAt:t.expiresAt,keyVersion:null!==(i=t.keyVersion)&&void 0!==i?i:void 0}}return s}))}getAllKeys(t){return e.__awaiter(this,void 0,void 0,(function*(){return yield this.request("GET",`/cache-keys/${this.class}/${this.id}${(null==t?void 0:t.prefix)?`?prefix=${null==t?void 0:t.prefix}`:""}`)}))}removeItem(t){return e.__awaiter(this,void 0,void 0,(function*(){if(!t)throw new Error("No name passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}/${t}`)}))}removeItems(t){return e.__awaiter(this,void 0,void 0,(function*(){if(!t||0===t.length)throw new Error("No names passed!");yield this.request("DELETE",`/cache/${this.class}/${this.id}`,t)}))}incrementItem(t){return e.__awaiter(this,arguments,void 0,(function*(e,t=1,i){var n;if(!e)throw new Error("No name passed!");if(null==t)throw new Error("No value passed!");if("number"!=typeof t)throw new Error("Value needs to be a number!");const r=(null==i?void 0:i.ttl)||this.ttl,s=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/increment`,{value:t,ttl:r});return{value:null==s?void 0:s.value,expiresAt:null==s?void 0:s.expiresAt,keyVersion:null!==(n=null==s?void 0:s.keyVersion)&&void 0!==n?n:void 0}}))}decrementItem(t){return e.__awaiter(this,arguments,void 0,(function*(e,t=1,i){var n;if(!e)throw new Error("No name passed!");if(null==t)throw new Error("No value passed!");if("number"!=typeof t)throw new Error("Value needs to be a number!");const r=(null==i?void 0:i.ttl)||this.ttl,s=yield this.request("POST",`/cache/${this.class}/${this.id}/${e}/decrement`,{value:t,ttl:r});return{value:null==s?void 0:s.value,expiresAt:null==s?void 0:s.expiresAt,keyVersion:null!==(n=null==s?void 0:s.keyVersion)&&void 0!==n?n:void 0}}))}clear(){return e.__awaiter(this,void 0,void 0,(function*(){yield this.request("DELETE",`/cache/${this.class}/${this.id}`)}))}};
